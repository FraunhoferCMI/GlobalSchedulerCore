
from datetime import datetime, timedelta
import numpy
import csv
import pandas
from gs_utilities import get_schedule

SSA_SCHEDULE_RESOLUTION = 60
SSA_PTS_PER_SCHEDULE = 24
SSA_SCHEDULE_DURATION = 24


##############################################################################
def generate_schedule_timestamps():
    """
    generates a list of time stamps associated with the next schedule to be generated by the optimizer.  These
    are the time indices of the scheduled power commmands (i.e., from SundialResource.schedule_var
    :return: schedule_timestamps - a list of datetimes, starting at the next schedule start, time step
    equal to SSA_SCHEDULE_RESOLUTION, and continuing until SSA_SCHEDULE_DURATION
    """
    MINUTES_PER_HR = 60

    now = datetime.utcnow()
    minutes = now.minute
    rem = minutes % SSA_SCHEDULE_RESOLUTION  # GS_SCHEDULE
    new_time = now - timedelta(minutes=rem) # todo - temp fix - moves forecast to tstep-1
    schedule_start_time = new_time.replace(second=0, microsecond=0)


    # generate the list of timestamps that will comprise the next forecast:
    schedule_timestamps = [schedule_start_time +
                           timedelta(minutes=t) for t in range(0,
                                                               SSA_SCHEDULE_DURATION * MINUTES_PER_HR,
                                                               SSA_SCHEDULE_RESOLUTION)]
    return schedule_timestamps

##############################################################################
def cfg_loadshape(schedule_timestamps):
    dir = "/home/parallels/sundial/volttron/services/contrib/GlobalSchedulerCore/GS_Optimizer/"
    loadshape_file = "loadshape_irronly.csv"
    csv_name = (dir + loadshape_file)
    print(csv_name)

    ls_array = []
    ts_array = []

    with open(csv_name, 'rb') as csvfile:
        csv_data = csv.reader(csvfile)

        for row in csv_data:
            ts_array.append(datetime.strptime(row[0], "%Y-%m-%dT%H:%M:%S"))
            ls_array.append(float(row[1]))

    loadshapes = pandas.Series(data=ls_array, index=ts_array)
    target_profile = numpy.array(loadshapes.get(schedule_timestamps))

    print(str(schedule_timestamps))
    print (str(target_profile))


if __name__ == '__main__':
    # Entry point for script

    target_profile = numpy.array([0.0] * SSA_PTS_PER_SCHEDULE)
    if (0):
        for ii in range(0, 6 * int(60 / SSA_SCHEDULE_RESOLUTION)):
            target_profile[ii] = 300

        for ii in range(6 * int(60 / SSA_SCHEDULE_RESOLUTION), 21 *int(60 /SSA_SCHEDULE_RESOLUTION)):
            target_profile[ii] = 450

        for ii in range(21 *int(60 /SSA_SCHEDULE_RESOLUTION), 24 *int(60 /SSA_SCHEDULE_RESOLUTION)):
            target_profile[ii] = 300
    else:
        # works well w/day 202 from the nyc file
        target_profile = numpy.array([0, 0, 0, 0, 0, -200, -200, -200, -200, -300, -300, -200, -200, -200, -200, -200, -200, -200, -200, 0, 0, 0, 0, 0])


    ts = [datetime(year=2018, month=1, day = 1, hour=0, minute=0, second=0)+timedelta(hours=t) for t in range(0,8759)]
    ls = []
    for ii in range(0,365):
        ls.extend(target_profile.tolist())


    ts_str = numpy.array([t.strftime("%Y-%m-%dT%H:%M:%S") for t in ts])

    f = open("/home/parallels/sundial/volttron/services/contrib/GlobalSchedulerCore/GS_Optimizer/loadshape_irronly.csv", "w")
    #numpy.savetxt(f, zip(ts_str, ls), delimiter=',', fmt=['%s19', '%f'])

    #f = open("submission2.csv", "w")
    #f.write("{},{}\n".format("Name1", "Name2"))
    for x in zip(ts_str, ls):
        f.write("{},{}\n".format(x[0], x[1]))
    f.close()

    #csv_name = ("/home/parallels/sundial/volttron/services/contrib/GlobalSchedulerCore/GS_Optimizier/loadshape.csv")
    #with open(csv_name, 'wb') as csvfile:
    #    results_writer = csv.writer(csvfile)
    #    results_writer.writerow(least_cost_soln.state_vars["DemandForecast_kW"])
    #    results_writer.writerow(init_soln.state_vars["DemandForecast_kW"])


    print("done")
    cfg_loadshape(generate_schedule_timestamps())
